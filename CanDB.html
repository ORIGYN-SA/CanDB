<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="CanDB.html">CanDB</a></li></li><li><li><a href="CanDBAdmin.html">CanDBAdmin</a></li></li><li><li><a href="CanisterActions.html">CanisterActions</a></li></li><li><li><a href="CanisterMap.html">CanisterMap</a></li></li><li><li><a href="Entity.html">Entity</a></li></li><li><li><a href="HashTree.html">HashTree</a></li></li><li><li><a href="InterfaceSpec.html">InterfaceSpec</a></li></li><li><li><a href="RangeTree.html">RangeTree</a></li></li><li><li><a href="SingleCanisterCanDB.html">SingleCanisterCanDB</a></li></li><li><li><a href="Utils.html">Utils</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.ScalingLimitType">ScalingLimitType</a></li></li><li><li><a href="#type.ScalingOptions">ScalingOptions</a></li></li><li><li><a href="#type.DB">DB</a></li></li><li><li><a href="#type.DBInitOptions">DBInitOptions</a></li></li><li><li><a href="#init">init</a></li></li><li><li><a href="#type.GetOptions">GetOptions</a></li></li><li><li><a href="#skExists">skExists</a></li></li><li><li><a href="#get">get</a></li></li><li><li><a href="#type.PutOptions">PutOptions</a></li></li><li><li><a href="#put">put</a></li></li><li><li><a href="#type.ReplaceOptions">ReplaceOptions</a></li></li><li><li><a href="#replace">replace</a></li></li><li><li><a href="#type.UpdateOptions">UpdateOptions</a></li></li><li><li><a href="#update">update</a></li></li><li><li><a href="#type.DeleteOptions">DeleteOptions</a></li></li><li><li><a href="#delete">delete</a></li></li><li><li><a href="#type.RemoveOptions">RemoveOptions</a></li></li><li><li><a href="#remove">remove</a></li></li><li><li><a href="#type.ScanOptions">ScanOptions</a></li></li><li><li><a href="#type.ScanResult">ScanResult</a></li></li><li><li><a href="#scan">scan</a></li></li></ul></nav><div class="documentation"><h1>CanDB</h1><p>The CanDB module, containing all methods for initializing and interacting with the CanDB data structure</p>
<div class="declaration"><h4 class="type-declaration" id="type.ScalingLimitType"><span class="keyword">type </span><span class="type">ScalingLimitType</span> = {#count : <span class="type">Nat</span>; #heapSize : <span class="type">Nat</span>}</h4><p><p>Auto-Scaling Limit Type</p>
<p>A developer can choose to auto-scale by the count of entities that have been inserted or by the canister heap size</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.ScalingOptions"><span class="keyword">type </span><span class="type">ScalingOptions</span> = { autoScalingHook : <a href="#type.AutoScalingCanisterSharedFunctionHook"><span class="type">AutoScalingCanisterSharedFunctionHook</span></a>; sizeLimit : <a href="#type.ScalingLimitType"><span class="type">ScalingLimitType</span></a> }</h4><p><p>ScalingOptions</p>
<p>autoScalingHook - The auto-scaling shared function in charge of scaling (located on the Index canister)
sizeLimit - the auto-scaling limit for the canister: either limit the auto-scaling by the count or the heap size of the canister</p>
<p>Once a canister passes the sizeLimit, it will trigger an inter-canister call from the canister storage partition to the
autoScalingHook to spin up a new canister for that partition. Then the scaling status is set to #complete, meaning that 
further insertions (after messages processed in that same consensus round) are sent to the newly spun up canister. However, 
updates to <strong>existing</strong> entity records in a canister storage partition can still happen until the canister hits the 1.75GB 
limit, held via the HEAP_SIZE_UPDATE LIMIT constant.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.DB"><span class="keyword">type </span><span class="type">DB</span> = { pk : <a href="Entity.html#type.PK"><span class="type">E.PK</span></a>; <span class="keyword">var </span>data : <a href="RangeTree.html#type.RangeTree"><span class="type">RT.RangeTree</span></a>; <span class="keyword">var </span>count : <span class="type">Nat</span>; <span class="keyword">var </span>scalingOptions : <a href="#type.ScalingOptions"><span class="type">ScalingOptions</span></a>; <span class="keyword">var </span>scalingStatus : {#not_started; #started; #complete} }</h4><p><p>CanDB Core</p>
<p>pk - the partition key of the CanDB instance. This also corresponds to the PK of the canister storage partition
data - where the data for CanDB is stored
count - the size/count of elements in CanDB (can be used for limit)
scalingOptions - ScalingOptions</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.DBInitOptions"><span class="keyword">type </span><span class="type">DBInitOptions</span> = { pk : <a href="Entity.html#type.PK"><span class="type">E.PK</span></a>; scalingOptions : <a href="#type.ScalingOptions"><span class="type">ScalingOptions</span></a> }</h4><p></p></div><div class="declaration"><h4 class="function" id="init"><code><span class="keyword">public func </span><span class="fnname">init</span>(<span class="parameter">options</span> : <a href="#type.DBInitOptions"><span class="type">DBInitOptions</span></a>) : <a href="#type.DB"><span class="type">DB</span></a></code></h4><p><p>initializes a CanDB data structure</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.GetOptions"><span class="keyword">type </span><span class="type">GetOptions</span> = { sk : <a href="Entity.html#type.SK"><span class="type">E.SK</span></a> }</h4><p></p></div><div class="declaration"><h4 class="function" id="skExists"><code><span class="keyword">public func </span><span class="fnname">skExists</span>(<span class="parameter">db</span> : <a href="#type.DB"><span class="type">DB</span></a>, <span class="parameter">sk</span> : <a href="Entity.html#type.SK"><span class="type">E.SK</span></a>) : <span class="type">Bool</span></code></h4><p><p>Returns a boolean indicating if an entity with a matching SK is present in CanDB</p>
</p></div><div class="declaration"><h4 class="function" id="get"><code><span class="keyword">public func </span><span class="fnname">get</span>(<span class="parameter">db</span> : <a href="#type.DB"><span class="type">DB</span></a>, <span class="parameter">options</span> : <a href="#type.GetOptions"><span class="type">GetOptions</span></a>) : ?<a href="Entity.html#type.Entity"><span class="type">E.Entity</span></a></code></h4><p><p>Get an entity if it exists in the DB</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.PutOptions"><span class="keyword">type </span><span class="type">PutOptions</span> = { sk : <a href="Entity.html#type.SK"><span class="type">E.SK</span></a>; attributes : [(<a href="Entity.html#type.AttributeKey"><span class="type">E.AttributeKey</span></a>, <a href="Entity.html#type.AttributeValue"><span class="type">E.AttributeValue</span></a>)] }</h4><p></p></div><div class="declaration"><h4 class="function" id="put"><code><span class="keyword">public func </span><span class="fnname">put</span>(<span class="parameter">db</span> : <a href="#type.DB"><span class="type">DB</span></a>, <span class="parameter">options</span> : <a href="#type.PutOptions"><span class="type">PutOptions</span></a>) : <span class="keyword">async </span>()</code></h4><p><p>Create an entity or replace an entity if exists in the DB
Auto scales by signaling the index canister to create a new canister with this PK if at capacity</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.ReplaceOptions"><span class="keyword">type </span><span class="type">ReplaceOptions</span> = <a href="#type.PutOptions"><span class="type">PutOptions</span></a></h4><p></p></div><div class="declaration"><h4 class="function" id="replace"><code><span class="keyword">public func </span><span class="fnname">replace</span>(<span class="parameter">db</span> : <a href="#type.DB"><span class="type">DB</span></a>, <span class="parameter">options</span> : <a href="#type.ReplaceOptions"><span class="type">ReplaceOptions</span></a>) : <span class="keyword">async </span>?<a href="Entity.html#type.Entity"><span class="type">E.Entity</span></a></code></h4><p><p>Create an entity or replace an entity if exists in the DB, returning the replaced entity
Auto scales by signaling the index canister to create a new canister with this PK if at capacity</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.UpdateOptions"><span class="keyword">type </span><span class="type">UpdateOptions</span> = { sk : <a href="Entity.html#type.SK"><span class="type">E.SK</span></a>; updateAttributeMapFunction : (?<a href="Entity.html#type.AttributeMap"><span class="type">E.AttributeMap</span></a>) -&gt; <a href="Entity.html#type.AttributeMap"><span class="type">E.AttributeMap</span></a> }</h4><p></p></div><div class="declaration"><h4 class="function" id="update"><code><span class="keyword">public func </span><span class="fnname">update</span>(<span class="parameter">db</span> : <a href="#type.DB"><span class="type">DB</span></a>, <span class="parameter">options</span> : <a href="#type.UpdateOptions"><span class="type">UpdateOptions</span></a>) : ?<a href="Entity.html#type.Entity"><span class="type">E.Entity</span></a></code></h4><p><p>Similar to replace(), but provides the ability to pass a developer defined update function
controlling how specific attributes of the entity are updated on match.</p>
<p>See the create() and update() functions in examples/simpleDB/src/main.mo, and the tests in
updateSuite() in test/HashTreeTest for some examples of how to use CanDB.update()</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.DeleteOptions"><span class="keyword">type </span><span class="type">DeleteOptions</span> = { sk : <a href="Entity.html#type.SK"><span class="type">E.SK</span></a> }</h4><p></p></div><div class="declaration"><h4 class="function" id="delete"><code><span class="keyword">public func </span><span class="fnname">delete</span>(<span class="parameter">db</span> : <a href="#type.DB"><span class="type">DB</span></a>, <span class="parameter">options</span> : <a href="#type.DeleteOptions"><span class="type">DeleteOptions</span></a>) : ()</code></h4><p><p>Removes an entity from the DB if exists</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.RemoveOptions"><span class="keyword">type </span><span class="type">RemoveOptions</span> = <a href="#type.DeleteOptions"><span class="type">DeleteOptions</span></a></h4><p></p></div><div class="declaration"><h4 class="function" id="remove"><code><span class="keyword">public func </span><span class="fnname">remove</span>(<span class="parameter">db</span> : <a href="#type.DB"><span class="type">DB</span></a>, <span class="parameter">options</span> : <a href="#type.RemoveOptions"><span class="type">RemoveOptions</span></a>) : ?<a href="Entity.html#type.Entity"><span class="type">E.Entity</span></a></code></h4><p><p>Remove an entity from the DB and return that entity if exists</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.ScanOptions"><span class="keyword">type </span><span class="type">ScanOptions</span> = { skLowerBound : <a href="Entity.html#type.SK"><span class="type">E.SK</span></a>; skUpperBound : <a href="Entity.html#type.SK"><span class="type">E.SK</span></a>; limit : <span class="type">Nat</span>; ascending : ?<span class="type">Bool</span> }</h4><p><p>Options passed to scan</p>
<p>pk - type Text: The Partition Key
skLowerBound - The Sort Key lower bound to scan from (inclusive)
skUpperBound - The Sort Key upper bound to scan from (inclusive)
limit - The limit of entries to scan within the sk bounds at a given time
ascending - Determines the order of results and where scanning will start from, defaults to ascending (starting from the skLowerBound and ending at the skUpperBound)</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.ScanResult"><span class="keyword">type </span><span class="type">ScanResult</span> = { entities : [<a href="Entity.html#type.Entity"><span class="type">E.Entity</span></a>]; nextKey : ?<a href="Entity.html#type.SK"><span class="type">E.SK</span></a> }</h4><p><p>Return type of scan()</p>
<p>entities - array of entities that match the scan
nextKey - next key to be evaluated when the scan limit is hit, is ideal for pagination (i.e. if the limit was hit and the user desires to scan/view more matching results)</p>
</p></div><div class="declaration"><h4 class="function" id="scan"><code><span class="keyword">public func </span><span class="fnname">scan</span>(<span class="parameter">db</span> : <a href="#type.DB"><span class="type">DB</span></a>, <span class="parameter">options</span> : <a href="#type.ScanOptions"><span class="type">ScanOptions</span></a>) : <a href="#type.ScanResult"><span class="type">ScanResult</span></a></code></h4><p><p>Scans the DB by partition key, a lower/upper bounded sort key range, and a desired result limit
Returns 0 or more items from the db matching the conditions of the ScanOptions passed</p>
</p></div></div></body></html>